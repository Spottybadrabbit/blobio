#!/usr/bin/env perl
#
#  Synopsis:
#	Build a chain of brr log files, starting from a recent udig set
#  Usage:
#	bio-chain head-udig-set
#  Exit Status:
#	0	all wrap sets exist and written
#	1	chain terminated because set does not exist
#	8	error occured
#

my $prog = 'bio-chain';

my $BRR_RE = qr{

	#  start time of request: YYYY-MM-DDThh:mm:ss.ns[+-]HH:MM
	(2\d\d\d-				#  year
		(?:(?:0[0-9])|11|12)-		#  month
		(?:(?:[012][0-9])|30|31)T	#  day followed by T
		(?:[0-2]\d):			#  hour
		(?:[0-5]\d):			#  minute
		(?:[0-5]\d)\.			#  second
		(?:\d{1,9})			#  nanoseconds
		[+-]\d\d:\d\d)			#  time zone offset
						\t
	#  netflow name~parameter
	[a-z][a-z0-9]{0,7}~[[:graph:]]{1,128}
						\t
	#  request verb
	(get|put|give|take|eat|wrap|roll)
						\t
	#  uniform digest
	([a-z][a-z0-9]{0,7}:[[:graph:]]{32,128})
						\t
	#  chat history
	(ok|(?:ok,ok)|(?:ok,ok,ok)|no|(?:ok,no)|(?:ok,ok,no))
						\t
	#  blob size
	\d{1,19}				\t

	#  wall time duration: sec32.nsec
	\d{1,10}\.\d{9}
						\n
}sx;

#  Note: need to verify ENV{BLOBIO_SERVICE} exists
my $SERVICE = "--service $ENV{BLOBIO_SERVICE}";

$SIG{__DIE__} = sub
{
	printf STDERR "$prog: ERROR: @_\n";
	exit 8;
};

#
#  Verify the udig is valid or does not exist.
#
#  Return:
#	0	blob points to existing set of udigs
#	1	blob does not exist
#
sub frisk_udig_set
{
	my $udig_set = $_[0];
	my $UDIG = "--udig $udig_set";

	my $status = system("blobio empty $UDIG") >> 8;
	die "unexpected frisk empty udig: $udig_set" if $status == 0;

	die "blobio frisk empty failed: exit status=$status" if $status != 1;

	my $EAT;
	$status = system("blobio eat $UDIG $SERVICE");
	die "blobio eat frisk failed: exit status=$status" if $status > 1;

	my %ELEMENTS;
	return \%ELEMENTS if $status == 1;

	#  open the set of udigs
	my $UDIG_SET;
	open($UDIG_SET, "blobio get $UDIG $SERVICE |") or
				die("open(blobio frisk udig set) failed: $!");

	#  scan the udig set for correctness
	while (<$UDIG_SET>) {
		chomp;
		die "blob is not udig set: $_[0]" unless
				m/^[a-z][a-z0-9]{0,7}:[[:graph:]]{32,128}$/ &&
				m/^[[:ascii:]]*$/
		;
		die "udig set has a duplicate: $udig_set"
						if $ELEMENTS{$_};
		$ELEMENTS{$_} = 1;
	}
	close($UDIG_SET) or die "close(frisk udig set) failed: $!";
	return \%ELEMENTS;
}

#  extract the wrap/roll tuples from a particular brr log 

sub scan_brr_log
{
	my $brr_udig = $_[0];
	my $UDIG = "--udig $brr_udig";
	my @wrap_roll;

	my $BRR_LOG;
	open($BRR_LOG, "blobio get $UDIG $SERVICE |") or
				die "open(scan brr blobio get) failed: $!";
	while (<$BRR_LOG>) {
		die "row has non ascii characters"
				unless m/^[[:ascii:]]*$/;

		my $len = length($_);
		die "row is < 95 or > 370 characters"
				unless 95 <=$len&&$len <= 370;
		die "row in brr log is not a blob request record: $_"
				unless m/^${BRR_RE}/;
		my $start_time = $1;
		my $verb = $2;
		my $udig = $3;
		my $chat_history = $4;
		next unless ($verb eq 'wrap' || $verb eq 'roll') &&
				$chat_history eq 'ok';
		push @wrap_roll, "$verb	$udig	$start_time";
	}
	close($BRR_LOG) or die "close(scan brr) failed: $!";
	return \@wrap_roll;
}

die "wrong number arguments: got ", scalar(@ARGV), ', expected 1'
	unless @ARGV == 1
;

my $udig_set = $ARGV[0];

while ($udig_set) {
	
	my $ELEMENTS = frisk_udig_set($udig_set);

	#  no elements in the udig set

	exit 1 if %${ELEMENTS} == 0;

	#  find the brr log with the roll

	my $roll;
	foreach my $brr_log (keys %${ELEMENTS}) {
		my $wrap_roll_row = scan_brr_log $brr_log;
		die "brr log has no wrap or roll request: $udig_set ->$brr_log"
					unless @$wrap_roll_row > 0;
		for my $wr (@$wrap_roll_row) {
			next unless $wr =~ /^roll/;
			die "roll occurs more than one in udig set: $udig_set"
							if $roll;
			$roll = $wr;
		}
	}
	print $udig_set, "\n", "\t-> ", $roll, "\n";
	die "no roll in brr logs for udig set: $udig_set" unless $roll;
	$roll = substr($roll, 5);
	$udig_set = substr($roll, 0, index($roll, "\t"));
}

exit 0;
