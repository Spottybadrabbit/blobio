#!/usr/bin/env perl
#
#  Synopsis:
#	Build a directed acylic graph of wrap/roll BRR log files.
#  Usage:
#	bio-chain head-udig-set
#

my $prog = 'bio-chain';

#  match a blob request record in wrap
my $BRR_RE = qr{

	#  start time of request: YYYY-MM-DDThh:mm:ss.ns[+-]HH:MM
	(2\d\d\d-				#  year
		(?:(?:0[0-9])|10|11|12)-	#  month
		(?:(?:[012][0-9])|30|31)T	#  day followed by T
		(?:[0-2]\d):			#  hour
		(?:[0-5]\d):			#  minute
		(?:[0-5]\d)\.			#  second
		(?:\d{1,9})			#  nanoseconds
		[+-]\d\d:\d\d)			#  time zone offset
						\t
	#  netflow name~parameter
	[a-z][a-z0-9]{0,7}~[[:graph:]]{1,128}
						\t
	#  request verb
	(get|put|give|take|eat|wrap|roll)
						\t
	#  uniform digest
	([a-z][a-z0-9]{0,7}:[[:graph:]]{32,128})
						\t
	#  chat history
	(ok|(?:ok,ok)|(?:ok,ok,ok)|no|(?:ok,no)|(?:ok,ok,no))
						\t
	#  blob size
	\d{1,19}				\t

	#  wall time duration: sec32.nsec
	\d{1,10}\.\d{9}
						\n
}sx;

#  Note: need to verify ENV{BLOBIO_SERVICE} exists
my $SERVICE = "--service $ENV{BLOBIO_SERVICE}";

$SIG{__DIE__} = sub
{
	printf STDERR "$prog: ERROR: @_\n";
	exit 8;
};

#
#  Verify the udig is valid or does not exist.
#
#  Return:
#	0	blob points to existing set of udigs
#	1	blob does not exist
#
sub frisk_udig_set
{
	my $udig_set = $_[0];
	my $UDIG = "--udig $udig_set";

	my $status = system("blobio empty $UDIG") >> 8;
	die "unexpected frisk empty udig: $udig_set" if $status == 0;

	die "blobio frisk empty failed: exit status=$status" if $status != 1;

	my $EAT;
	$status = system("blobio eat $UDIG $SERVICE");
	die "blobio eat frisk failed: exit status=$status" if $status > 1;

	my %ELEMENTS;
	return \%ELEMENTS if $status == 1;

	#  open the set of udigs
	my $UDIG_SET;
	open($UDIG_SET, "blobio get $UDIG $SERVICE |") or
				die("open(blobio frisk udig set) failed: $!");

	#  scan the udig set for correctness
	while (<$UDIG_SET>) {
		chomp;
		die "blob is not udig set: $_[0]" unless
				m/^[a-z][a-z0-9]{0,7}:[[:graph:]]{32,128}$/ &&
				m/^[[:ascii:]]*$/
		;
		die "udig set has a duplicate: $udig_set"
						if $ELEMENTS{$_};
		$ELEMENTS{$_} = 1;
	}
	close($UDIG_SET) or die "close(frisk udig set) failed: $!";
	return \%ELEMENTS;
}

#  extract the wrap/roll tuples from a particular brr log 

sub scan_brr_log
{
	my $brr_udig = $_[0];
	my $UDIG = "--udig $brr_udig";
	my @wrap_roll;

	my $BRR_LOG;
	open($BRR_LOG, "blobio get $UDIG $SERVICE |") or
				die "open(scan brr blobio get) failed: $!";
	my $rc = 0;
	while (<$BRR_LOG>) {
		$rc++;

		die "row $rc has non ascii characters: $brr_udig"
						unless m/^[[:ascii:]]*$/;

		my $len = length($_);
		die "row $rc is < 95 or > 370 characters: $brr_udig"
						unless 95 <=$len&&$len <= 370;
		die "row $rc does not match regex of brr: $brr_udig: $_"
							unless m/^${BRR_RE}/;
		my $start_time = $1;
		my $verb = $2;
		my $udig = $3;
		my $chat_history = $4;
		next unless ($verb eq 'wrap' || $verb eq 'roll') &&
						$chat_history eq 'ok';
		push @wrap_roll, "$verb	$udig	$start_time";
	}
	close($BRR_LOG) or die "close(scan brr) failed: $!";
	return \@wrap_roll;
}

sub WARN
{
	printf STDERR "WARN: ", @_, "\n";
}

die "wrong number arguments: got ", scalar(@ARGV), ', expected 1'
					unless @ARGV == 1
;

my $udig_set = $ARGV[0];

my $what = 'udig_set';
while ($udig_set) {

	my $ELEMENTS = frisk_udig_set($udig_set);

	#  no elements in the udig set

	exit 1 if %${ELEMENTS} == 0;

	#  for the given set of brr logs, find the

	my ($roll, $wrap);
	foreach my $brr_log (keys %${ELEMENTS}) {
		my $wrap_roll_row = scan_brr_log $brr_log;
		unless (@$wrap_roll_row > 0) {
			WARN "no wrap or roll in brr log: $brr_log";
			next;
		}
		die "brr log has no wrap or roll request: $brr_log"
						unless @$wrap_roll_row > 0;
		$wrap = '';
		for my $wr (@$wrap_roll_row) {
			my ($verb, $udig, $start_time) = split("\t", $wr);
			if ($verb eq 'wrap') {
				die 'wrap occurs more than once in brr log: ' .
				     $brr_log if $wrap;
				 $wrap = $udig;
			} else {
				die 'roll occurs more than one in udig set: ' .
							$udig_set if $roll;
				$roll = $udig;
			}
		}
		if ($roll) {
			print "brr_log/$brr_log	roll/$roll\n";
		} else {
			print "brr_log/$brr_log	wrap/$wrap\n";
		}
		print "udig_set/$udig_set	brr_log/$brr_log\n";
	}
	if ($roll) {
		$udig_set = $roll;
	} else {
		WARN "no roll in any brr logs in udig_set: $udig_set";
		next unless $wrap;

		die "no wrap in any brr logs in udig_set: $udig_set"
								unless $wrap;
		$udig_set = $wrap;
	}
}

exit 0;
