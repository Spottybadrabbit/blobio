#!/usr/bin/env perl
#
#  Synopsis:
#	Build a summary of all blobs in the "block chain" of brr log files.
#  Usage:
#	sync-brr-chain
#
my $date = `date`;

use File::Temp;

my $prog = 'sync-brr-chain';

my (
	%BRR_LOG,
	@ROLL_SET,
	%UDIG,
	%WRAP_SET,
	$MIN_BRR_LOG_START_TIME,
	$MAX_BRR_LOG_START_TIME,
	%NO_BRR_LOG,
	%BYTE_COUNT,
	%TAKEN,
	%OK_VERB_COUNT,
);

#  match a udig

my $UDIG_RE = qr{
	[a-z][a-z0-9]{0,7}			#  algorithm
		:
	[[:graph:]]{32,128}			#  digest
}sx;

#  match a blob request record in log file
my $BRR_RE = qr{

	#  start time of request: YYYY-MM-DDThh:mm:ss.ns[+-]HH:MM
	(2\d\d\d-				#  year
		(?:(?:0[0-9])|10|11|12)-	#  month
		(?:(?:[012][0-9])|30|31)T	#  day followed by T
		(?:[0-2]\d):			#  hour
		(?:[0-5]\d):			#  minute
		(?:[0-5]\d)\.			#  second
		(?:\d{1,9})			#  nanoseconds
		[+-]\d\d:\d\d			#  time zone offset
	)
						\t
	#  netflow name~parameter
	[a-z][a-z0-9]{0,7}~[[:graph:]]{1,128}
						\t
	#  request verb
	(get|put|give|take|eat|wrap|roll)
						\t
	#  uniform digest
	([a-z][a-z0-9]{0,7}:[[:graph:]]{32,128})
						\t
	#  chat history
	(ok|(?:ok,ok)|(?:ok,ok,ok)|no|(?:ok,no)|(?:ok,ok,no))
						\t
	#  blob size
	(\d{1,19})				\t

	#  wall time duration: sec32.nsec
	\d{1,10}\.\d{9}
						\n
}sx;

$SIG{__DIE__} = sub
{
	printf STDERR "$prog: ERROR: @_\n";
	exit 8;
};

my $BLOBIO_SERVICE = $ENV{BLOBIO_SERVICE};
die 'environment variable not defined: BLOBIO_SERVICE' unless $BLOBIO_SERVICE;
my $SERVICE = "--service $BLOBIO_SERVICE";
my $BLOBIO_GET_SERVICE = $ENV{BLOBIO_GET_SERVICE} ?
				$ENV{BLOBIO_GET_SERVICE} :
				$ENV{BLOBIO_SERVICE}
;
my $GET_SERVICE = "--service $BLOBIO_GET_SERVICE";

chomp $date;
print <<END;
#
#  Job Start Time: $date
#
#  BLOBIO_SERVICE: $BLOBIO_SERVICE
#  BLOBIO_GET_SERVICE: $BLOBIO_GET_SERVICE
END

my $tmp_file = File::Temp->new()->filename;
die "can not create temp file name: $!" unless $tmp_file;
print <<END;
#  Temp Work File: $tmp_file
END

#
#  Verify the udig is valid or does not exist.
#
#  Return:
#	0	blob points to existing set of udigs
#	1	blob does not exist
#
sub frisk_wrap_set
{
	my $udig_set = $_[0];
	my $UDIG = "--udig $udig_set";

	my $status = system("blobio empty $UDIG") >> 8;
	die "unexpected frisk empty udig: $udig_set" if $status == 0;

	die "blobio frisk empty failed: exit status=$status" if $status != 1;

	my $EAT;
	$status = system("blobio eat $UDIG $GET_SERVICE");
	die "blobio eat frisk failed: exit status=$status" if $status > 1;

	my %ELEMENTS;
	return \%ELEMENTS if $status == 1;

	#  open the set of udigs
	my $WRAP_SET;
	open($WRAP_SET, "blobio get $UDIG $GET_SERVICE |") or
				die("open(blobio frisk wrap set) failed: $!");

	#  scan the udig set for correctness
	while (<$WRAP_SET>) {
		chomp;
		die "blob is not udig set: $_[0]" unless
				m/^[a-z][a-z0-9]{0,7}:[[:graph:]]{32,128}$/ &&
				m/^[[:ascii:]]*$/
		;
		die "udig set has a duplicate: $udig_set" if $ELEMENTS{$_};
		$ELEMENTS{$_} = 1;
	}
	close($WRAP_SET) or die "close(frisk udig set) failed: $!";
	return \%ELEMENTS;
}

sub WARN
{
	printf STDERR "WARN: ", @_, "\n";
}

die "wrong number arguments: got ", scalar(@ARGV), ', expected 0'
					unless @ARGV == 0
;

die 'environment var not defined: BLOBIO_SERVICE' unless $ENV{BLOBIO_SERVICE};

my $TAIL_WRAP;
open($TAIL_WRAP, "blobio wrap $SERVICE |") or
		die "open(blobio wrap) failed: $!";
my $tail_wrap_set = <$TAIL_WRAP>;
close($TAIL_WRAP) or die "close(blobio wrap) failed: $!";
chomp $tail_wrap_set;

die 'tail wrap set is not udig' unless $tail_wrap_set =~ m/^${UDIG_RE}$/;

print <<END;
#  Tail Wrap Set: $tail_wrap_set
END

my $oldest_wrap_set = $tail_wrap_set;

my $status = system("blobio roll --udig $tail_wrap_set $SERVICE");
print <<END;
#  Roll Exit Status: $status
END

die "blobio roll failed: exit status=$status" if $status;

my $wrap_set = $tail_wrap_set;

while ($wrap_set) {

	die "tail wrap set seen twice: $wrap_set" if $WRAP_SET{$wrap_set};
	$WRAP_SET{$wrap_set} = 1;

	my $ELEMENTS = frisk_wrap_set($wrap_set);

	#  no elements in the udig set

	exit 1 if %${ELEMENTS} == 0;

	#  scan the brr logs for timestamped udigs

	my $roll_set;
	foreach my $brr_log (keys %${ELEMENTS}) {
		next if $BRR_LOG{$brr_log};
		$BRR_LOG{$brr_log} = 1;

		my $command = 'blobio get '				.
			      "--udig $brr_log "			.
			      $GET_SERVICE				.
			      " --output-path $tmp_file"
		;
		if (my $status = system($command)) {
			$status >>= 8;
			die "blobio get brr log failed: exit status=$status"
				unless $status == 1
			;
			print "#  NO BRR Log: $brr_log\n"
					unless $NO_BRR_LOG{$brr_log};
			$NO_BRR_LOG{$brr_log} = 1;
			next;
		}
			
		my $BRR_LOG;
		open($BRR_LOG, "<$tmp_file") or
					die "open(tmp brr log) failed: $!";
		my $rc = 0;
		while (<$BRR_LOG>) {
			$rc++;
			die "row $rc is not brr in log: $brr_log"
							unless m/^${BRR_RE}$/;
			my $start_time = $1;
			my $verb = $2;
			my $udig = $3;
			my $chat_history = $4;
			my $blob_size = $5;

			$MAX_BRR_LOG_START_TIME = $start_time
			  if
			  	$MAX_BRR_LOG_START_TIME eq ''
				or
			  	$start_time > $MAX_BRR_LOG_START_TIME
			;
			$MIN_BRR_LOG_START_TIME = $start_time
			  if
			  	$MIN_BRR_LOG_START_TIME eq ''
				or
			  	$start_time < $MIN_BRR_LOG_START_TIME
			;

			next if $chat_history =~ /no$/;

			$OK_VERB_COUNT{$verb}++;

			#  blob was taken

			if ($verb eq 'take') {
				#  flag as taken unless seen more recently
				$TAKEN{$udig} = 1;
				delete $UDIG{$udig} if $UDIG{$udig};
				next;
			}

			#  record blob

			$UDIG{$udig} = $blob_size unless $UDIG{$udig};
			delete $TAKEN{$udig} if $TAKEN{$udig};

			next unless $verb eq 'roll' && $chat_history eq 'ok';

			die "roll defined more than once in udig set: $roll_set"
				if $roll_set
			;
			$roll_set = $udig;
		}
		close($BRR_LOG) or die "close(blobio get brr log) failed: $!";
		unlink($tmp_file) or die "unlink(tmp brr log) failed: $!";
	}
	last unless $roll_set;
	push @ROLL_SET, $roll_set;
	$wrap_set = $roll_set;
	$oldest_wrap_set = $wrap_set;
}

my $sum_blob_size = 0;
for my $udig (keys %UDIG) {
	$sum_blob_size += $UDIG{$udig};
	print $udig, "\n";
}

my $brr_log_count = scalar(%BRR_LOG);
my $roll_set_count = scalar(@ROLL_SET);
my $udig_count = scalar(%UDIG);
my $no_brr_log_set_count = scalar(%NO_BRR_LOG);
my $taken_count = scalar(%TAKEN);

my $average_blob_size;
$average_blob_size = sprintf('%0.f', $sum_blob_size / $udig_count)
			if $udig_count > 0
;
$date = `date`;
chomp $date;

my $pretty_sum_blob_size = $sum_blob_size;
if ($sum_blob_size >= 1099511627776) {		#  terabytes
	$pretty_sum_blob_size = sprintf('%.fTB', $sum_blob_size /1099511627776);

} elsif ($sum_blob_size >= 1073741824) {	#  gigabytes
	$pretty_sum_blob_size = sprintf('%.fGB', $sum_blob_size / 1073741824);
} elsif ($sum_blob_size >= 1048576) {		#  megabytes
	$pretty_sum_blob_size = sprintf('%.fMB', $sum_blob_size / 1048576);
} elsif ($sum_blob_size >= 1024) {
	$pretty_sum_blob_size = sprintf('%.fKB', $sum_blob_size / 1024);
} else {
	$pretty_sum_blob_size = "$sum_blob_size bytes";
}

print <<END;
#
#  Min BRR Log Start Time: $MIN_BRR_LOG_START_TIME
#  Max BRR Log Start Time: $MAX_BRR_LOG_START_TIME
#
#  BRR Log Count: $brr_log_count logs
#
#  Eat Ok Count: $OK_VERB_COUNT{eat}
#  Get Ok Count: $OK_VERB_COUNT{get}
#  Put Ok Count: $OK_VERB_COUNT{put}
#  Give Ok Count: $OK_VERB_COUNT{give}
#  Take Ok Count: $OK_VERB_COUNT{take}
#  Wrap Ok Count: $OK_VERB_COUNT{wrap}
#  Roll Ok Count: $OK_VERB_COUNT{roll}
#
#  Frisked Roll Set Count: $roll_set_count sets
#  Oldest Wrap Set: $oldest_wrap_set
#  UDig Count: $udig_count blobs
#  Total Blob Size: $pretty_sum_blob_size ($sum_blob_size bytes)
#  Average Blob Size: $average_blob_size bytes
#  No BRR Log Count: $no_brr_log_set_count blobs
#  Taken Count: $taken_count blobs
#
#  Job End Time: $date
#
END

exit 0;
