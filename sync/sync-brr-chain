#!/usr/bin/env perl
#
#  Synopsis:
#	Build a summary of all blobs in the "block chain" of brr log files.
#  Usage:
#	sync-brr-chain
#

my $prog = 'sync-brr-chain';

my (%BRR_LOG, @ROLL_SET, %UDIG, %WRAP_SET, $MIN_START_TIME, $MAX_START_TIME);

#  match a udig

my $UDIG_RE = qr{
	[a-z][a-z0-9]{0,7}			#  algorithm
		:
	[[:graph:]]{32,128}			#  digest
}sx;

#  match a blob request record in log file
my $BRR_RE = qr{

	#  start time of request: YYYY-MM-DDThh:mm:ss.ns[+-]HH:MM
	(2\d\d\d-				#  year
		(?:(?:0[0-9])|10|11|12)-	#  month
		(?:(?:[012][0-9])|30|31)T	#  day followed by T
		(?:[0-2]\d):			#  hour
		(?:[0-5]\d):			#  minute
		(?:[0-5]\d)\.			#  second
		(?:\d{1,9})			#  nanoseconds
		[+-]\d\d:\d\d)			#  time zone offset
						\t
	#  netflow name~parameter
	[a-z][a-z0-9]{0,7}~[[:graph:]]{1,128}
						\t
	#  request verb
	(get|put|give|take|eat|wrap|roll)
						\t
	#  uniform digest
	([a-z][a-z0-9]{0,7}:[[:graph:]]{32,128})
						\t
	#  chat history
	(ok|(?:ok,ok)|(?:ok,ok,ok)|no|(?:ok,no)|(?:ok,ok,no))
						\t
	#  blob size
	\d{1,19}				\t

	#  wall time duration: sec32.nsec
	\d{1,10}\.\d{9}
						\n
}sx;

#  Note: need to verify ENV{BLOBIO_SERVICE} exists
my $SERVICE = "--service $ENV{BLOBIO_SERVICE}";

$SIG{__DIE__} = sub
{
	printf STDERR "$prog: ERROR: @_\n";
	exit 8;
};

#
#  Verify the udig is valid or does not exist.
#
#  Return:
#	0	blob points to existing set of udigs
#	1	blob does not exist
#
sub frisk_wrap_set
{
	my $udig_set = $_[0];
	my $UDIG = "--udig $udig_set";

	my $status = system("blobio empty $UDIG") >> 8;
	die "unexpected frisk empty udig: $udig_set" if $status == 0;

	die "blobio frisk empty failed: exit status=$status" if $status != 1;

	my $EAT;
	$status = system("blobio eat $UDIG $SERVICE");
	die "blobio eat frisk failed: exit status=$status" if $status > 1;

	my %ELEMENTS;
	return \%ELEMENTS if $status == 1;

	#  open the set of udigs
	my $WRAP_SET;
	open($WRAP_SET, "blobio get $UDIG $SERVICE |") or
				die("open(blobio frisk udig set) failed: $!");

	#  scan the udig set for correctness
	while (<$WRAP_SET>) {
		chomp;
		die "blob is not udig set: $_[0]" unless
				m/^[a-z][a-z0-9]{0,7}:[[:graph:]]{32,128}$/ &&
				m/^[[:ascii:]]*$/
		;
		die "udig set has a duplicate: $udig_set" if $ELEMENTS{$_};
		$ELEMENTS{$_} = 1;
	}
	close($WRAP_SET) or die "close(frisk udig set) failed: $!";
	return \%ELEMENTS;
}

sub WARN
{
	printf STDERR "WARN: ", @_, "\n";
}

die "wrong number arguments: got ", scalar(@ARGV), ', expected 0'
					unless @ARGV == 0
;

die 'environment var not defined: BLOBIO_SERVICE' unless $ENV{BLOBIO_SERVICE};

my $Date = `date`;
chomp $Date;
print <<END;
#
#  Date: $Date
#
#  BLOBIO_SERVICE: $ENV{BLOBIO_SERVICE}
END

my $TAIL_WRAP;
open($TAIL_WRAP, "blobio wrap $SERVICE |") or die "open(blobio wrap) failed: $!";
my $tail_wrap_set = <$TAIL_WRAP>;
close($TAIL_WRAP) or die "close(blobio wrap) failed: $!";
chomp $tail_wrap_set;

print <<END;
#  Tail Wrap Set: $tail_wrap_set
END

my $status = system("blobio roll --udig $tail_wrap_set $SERVICE");
print <<END;
#  Roll Exit Status: $status
END

die "blobio roll failed: exit status=$status" if $status;

my $wrap_set = $tail_wrap_set;

while ($wrap_set) {

	die "tail wrap set seen twice: $wrap_set" if $WRAP_SET{$wrap_set};
	$WRAP_SET{$wrap_set} = 1;

	my $ELEMENTS = frisk_wrap_set($wrap_set);

	#  no elements in the udig set

	exit 1 if %${ELEMENTS} == 0;

	#  scan the brr logs for timestamped udigs

	my $roll_set;
	foreach my $brr_log (keys %${ELEMENTS}) {
		next if $BRR_LOG{$brr_log};
		$BRR_LOG{$brr_log} = 1;

		my $BRR_LOG;
		open($BRR_LOG, "blobio get --udig $brr_log $SERVICE |") or
				die "open(blobio get brr log) failed: $!";

		my $rc = 0;
		while (<$BRR_LOG>) {
			$rc++;
			die "row $rc is not brr in log: $brr_log"
							unless m/^${BRR_RE}$/;
			my $start_time = $1;
			my $verb = $2;
			my $udig = $3;
			my $chat_history = $4;

			$MAX_START_TIME = $start_time
			  if
			  	$MAX_START_TIME eq ''
				or
			  	$start_time > $MAX_START_TIME
			;
			$MIN_START_TIME = $start_time
			  if
			  	$MIN_START_TIME eq ''
				or
			  	$start_time < $MIN_START_TIME
			;

			next if $chat_history =~ /no$/;

			#  record most recent successfull start_time time
			if ($UDIG{$udig}) {
				$UDIG{$udig} = $start_time
					if $start_time > $UDIG{$udig}
			} else {
				$UDIG{$udig} = $start_time;
			}

			next unless $verb eq 'roll' && $chat_history eq 'ok';

			die "roll defined more than once in udig set: $wrap_set"
				if $roll_set
			;
			$roll_set = $udig;
		}
		close($BRR_LOG) or die "close(blobio get brr log) failed: $!";
	}
	last unless $roll_set;
	push @ROLL_SET, $roll_set;
	$wrap_set = $roll_set;
}

my $brr_log_count = scalar(%BRR_LOG);
my $roll_set_count = scalar(@ROLL_SET);
my $udig_count = scalar(%UDIG);
my $udig_set_count = scalar(%UDIG);

print <<END;
#
#  Min Start Time: $MIN_START_TIME
#  Max Start Time: $MAX_START_TIME
#
#  BRR Log Count: $brr_log_count logs
#  Roll Set Count: $roll_set_count sets
#  UDig Count: $udig_count blobs
#
END

foreach my $udig (keys %UDIG) {
	print $udig, "\n";
}

exit 0;
